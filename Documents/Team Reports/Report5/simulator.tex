\section{Simulator}

Soon after the first models of the robot were developed we began to think about the behaviour of the robot. It became apparent that the strategy team could benefit a lot from having a medium on which to make quick tests, instead of having to depend on the availability of the pitch. Consequently, a decision was made to build a simulator. Considering Java was the main language of the project, Java Swing was chosen as it is the primary Java GUI toolkit.\linebreak

The aim in designing the simulator was to imitate a pitch environment so that strategies could undergo preliminary debugging. Real pictures of the pitch, the ball and the robots, were taken and then used so that proportions did not have to be considered. As the goal of the simulation was to mimic the real robot and its use of  non-holonomic differential drive wheels, forward kinematics, which considered the speed of the wheels, were used to compute the robots future position and orientation.\linebreak
\begin{align}
\theta_{t} & = \frac{(V_{R}-V_{L})\Delta t}{b} + \theta_{0}\\
x_{t} & =x_0+ \frac{b(V_{R}+V_{L})}{2(V_{R}-V_{L})}[sin(\theta_{t})-sin(\theta_{0})]\\
y_{t} & =y_0- \frac{b(V_{R}+V_{L})}{2(V_{R}-V_{L})}[cos(\theta_{t})-cos(\theta_{0})]
\end{align}
A problem that occurred using this model was that if the speed of the left and right wheels were equal, the denominator in the equation is zero. One approach is to use a different approximation formula for this special case. It was decided that this is unneeded complication. Therefore, in order to have perfectly straight movement if the wheel speeds were equal, a very small floating point number was subtracted from one of the wheel speeds.\linebreak

For collision detection, there was an initial attempt at using an external physics library. However, the team’s usage of the simulator was very specific, a custom made physics library was made purely for these targeted purposes. Objects requiring collision detection needed to implement a CollisionListener class and are then registered with a central CollisionDetector. The CollisionDetector stores the objects into an ArrayList and loops through them. Each object registered must have a shape and each corner of every shape is checked for inclusion in any other object shape. If this is the case, both objects are notified and sent a Collision packet describing the specifics of the collision. The different objects handle their own specific collisions: the ball bounces off the walls of the pitch, the robots collide with each other and the walls, and the kicker kicks the ball at the angle the robot is facing. \linebreak

In order to improve strategy debugging efficiency, a class was implemented so that the strategy code could access to the drawing capabilities of the simulator extremely easy. This class abstracts all of the work needed to draw on the simulator’s screen and provides a better alternative to the previously scattered console printing statements that clogged the code. We were now easily able to visualize the state of execution of any algorithm, any calculation, or any navigation points used in the strategy. \linebreak

Mouse and keyboard shortcuts provide further functionality. For instance, repositioning the objects on the pitch and enabling and disabling the robot in use. This first addition allowed us to immediately test the behavior of the strategy in any possible case. The second one allowed us to stop the robot from executing commands. As a result, we were able to easily examine the current state and parameters of the strategy because they would automatically drawn on the simulator. \linebreak

Although no direct quantitative measurement can be obtained, it was features like this that proved to be crucial in early testing, debugging and optimization. All the tools available in the simulator were heavily utilized by the strategy team. Coming up with ways of streamlining and facilitating testing, meant we were able to solve problems more quickly and more effectively.